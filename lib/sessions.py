#!/usr/bin/env python3

"""
Helper functions to manage our stored session configurations.

Each session is stored as a directory on the local machine, containing files with configuration
information for the session.  This includes, among other things, the authentication information for
the remote array associated with the session, a history of all commands run for the session, and a
logfile generated by said commands.

All session directories are stored together in one central location.
"""

import json
import os
from pathlib import Path
from lib.exceptions import *


# TODO: include all extra logging that puresnap supports

# directory that stores all sessions
SESSION_PARENT_DIR = 'sessions'

# authentication file
AUTH_FILE = '.api-token'

# command history file
COMMAND_HISTORY_FILE = 'config_history'

# logfile
LOG_FILE = 'puresnap.log'

# list of all expected files
EXPECTED_FILES = (
    AUTH_FILE,
    COMMAND_HISTORY_FILE,
    LOG_FILE,
)

def ensure_session_parent_dir_exists():
    """
    Ensure that our session parent dir exists.
    """

    if not os.path.isdir(SESSION_PARENT_DIR):
        os.mkdir(SESSION_PARENT_DIR)


def add_session(name, config, overwrite=False):
    """
    Add a new session, given a string name for the session and a dictionary containing the config
    of the session.

    Throws an exception if the session already exists, unless we pass overwrite=True.
    """

    # make sure we don't already have a session with the given name
    ensure_session_parent_dir_exists()
    session_dir = os.path.join(SESSION_PARENT_DIR, name)

    if not overwrite:
        # assert not os.path.isdir(session_dir), 'session {} already exists'.format(name)
        if os.path.isdir(session_dir):
            raise SessionExistsError(session_dir)


    # create the session dir
    if not os.path.isdir(session_dir):
        os.mkdir(session_dir)

    # create all of our expected files, and chmod them accordingly
    for filename in EXPECTED_FILES:
        fullpath = os.path.join(session_dir, filename)
        Path(fullpath).touch(mode=0o600, exist_ok=True)

    # generate our auth config and store it
    auth_config = {
        'ip': config['address'],
        'token': config['api_token'],
    }

    authfile = os.path.join(session_dir, AUTH_FILE)
    with open(authfile, 'w') as f:
        json.dump(auth_config, f)


def remove_session(name):
    """
    Remove a session, given a string name for the session.

    Throws an exception if the session doesn't exist.
    """

    # make sure the session exists
    ensure_session_parent_dir_exists()
    session_dir = os.path.join(SESSION_PARENT_DIR, name)
    #assert os.path.isdir(session_dir), 'session {} does not exist'.format(name)
    if not os.path.isdir(session_dir):
        raise NoSessionException(session_dir)

    # to be safe, explicitly remove expected files and then the empty directory, rather than doing
    # the python equivalent of `rm -r`
    for filename in EXPECTED_FILES:
        filepath = os.path.join(session_dir, filename)
        if os.path.exists(filepath):
            os.remove(filepath)
    os.rmdir(session_dir)


def list_sessions(names=None):
    """
    List sessions.  If given a list of names, return those sessions.  Otherwise, return all
    sessions.

    Throws an exception if a named session doesn't exist.
    """

    # get the sessions which currently exist
    ensure_session_parent_dir_exists()
    if names is None:
        names = os.listdir(SESSION_PARENT_DIR)

    # read in the config info for our sessions
    info = {}
    try:
        for name in names:
            with open(os.path.join(SESSION_PARENT_DIR, name, AUTH_FILE)) as f:
                config = json.load(f)
            info[name] = {
                'address': config['ip'],
                'api_token': config['token'],
            }
    except:
        raise NoSessionException(names)
    # return our gathered information
    return info
